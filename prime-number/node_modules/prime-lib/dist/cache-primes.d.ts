/**
 * Return type from cachePrimes function.
 */
export interface IPrimesCache extends Iterable<number>, ArrayLike<number> {
    /**
     * Fast primes accessor from index. It is 100 times faster than via Proxy.
     */
    readonly fastIndex: {
        /**
         * Returns a prime from index (0-based), or throws an error when index
         * is invalid or outside the range (0 <= index < length).
         */
        get(index: number): number;
        /**
         * Number of primes in the cache.
         */
        readonly length: number;
    };
}
/**
 * Maximum number of primes for which gap <= 255, i.e. can fit into 1 byte.
 * After that, we have to compress gaps, by storing bit 8 in bit 0,
 * using the fact that all gaps (except between 2 and 3) are even.
 *
 * We make the distinction, because compression costs ~10% of performance.
 */
export declare const maxSmallGaps = 23163298;
/**
 * Creates a compressed cache of prime gaps, so primes can be quickly calculated
 * and accessed, while consuming only 1/8th of memory, compared to number-s.
 *
 * Access to primes is very fast, especially via indexes, for which access
 * is optimized via segments and forward steps prediction.
 *
 * Maximum cache size is 100mln primes.
 */
export declare function cachePrimes(n: number): IPrimesCache;
